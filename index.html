<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Bubble Tea Shop</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #loading { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: #FFE8AC; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 24px; 
            color: #F9CDD9; 
            z-index: 10;
            opacity: 1;
        }
        #tooltip {
            position: absolute;
            background: rgba(249, 205, 217, 0.95); /* Slightly less opacity for solidity */
            color: #FFE8AC;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: none;
            display: none;
            z-index: 5;
            border: 1px solid #FFE8AC;
        }
        #info-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #FFE8AC;
            color: #F9CDD9;
            padding: 25px;
            border-radius: 12px;
            max-width: 350px;
            display: none;
            z-index: 6;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            text-align: center;
        }
        #info-modal h2 {
            margin-top: 0;
            font-size: 20px;
        }
        #info-modal p {
            font-size: 16px;
        }
        #info-modal button {
            background: #F9CDD9;
            color: #FFE8AC;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        #menu {
            position: absolute;
            bottom: -300px; /* Adjusted for more space */
            left: 0;
            width: 100%;
            background: rgba(249, 205, 217, 0.95);
            color: #FFE8AC;
            padding: 25px;
            box-sizing: border-box;
            transition: bottom 0.5s ease;
            z-index: 5;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.2);
        }
        #menu h2 {
            margin-top: 0;
            text-align: center;
        }
        #menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        #menu li {
            margin: 10px;
            padding: 10px 20px;
            background: #FFE8AC;
            color: #F9CDD9;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(249, 205, 217, 0.8);
            color: #FFE8AC;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 5;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        #prev-btn, #next-btn {
            position: absolute;
            bottom: 20px;
            background: #F9CDD9;
            color: #FFE8AC;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 5;
            display: none; /* Show on mobile */
        }
        #prev-btn { left: 20px; }
        #next-btn { right: 20px; }
        @media (max-width: 768px) {
            #prev-btn, #next-btn { display: block; }
            #tooltip { display: none !important; } /* Disable tooltip on mobile */
        }
        #bottom-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 80%;
            max-width: 600px;
            z-index: 5;
        }
        #section-left, #section-right {
            font-size: 16px;
            color: #F9CDD9;
        }
        #progress {
            flex: 1;
            margin: 0 20px;
            height: 5px;
            background: #F9CDD9;
            border-radius: 5px;
            position: relative;
        }
        #progress-fill {
            height: 100%;
            background: #FFE8AC;
            border-radius: 5px;
            transition: width 0.5s ease;
        }
        .hotspot {
            position: absolute;
            width: 30px;
            height: 30px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            animation: pulse 1.5s infinite;
        }
        .inner-dot {
            width: 10px;
            height: 10px;
            background: red;
            border-radius: 50%;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        #about-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 232, 172, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 4;
            text-align: center;
            color: #F9CDD9;
            font-size: 18px;
            padding: 20px;
            opacity: 1;
            transition: opacity 1s ease;
        }
        #about-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #about-overlay h1 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        #about-overlay p {
            max-width: 600px;
            margin-bottom: 20px;
        }
        #enter-button {
            background: #F9CDD9;
            color: #FFE8AC;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Virtual Bubble Tea Shop...</div>
    <div id="tooltip"></div>
    <div id="info-modal">
        <h2 id="info-title"></h2>
        <p id="info-description"></p>
        <button onclick="closeModal()">Close</button>
    </div>
    <div id="menu">
        <h2>Bubble Tea Menu</h2>
        <ul>
            <li onclick="goToPosition(3)">Classic Milk Tea</li>
            <li onclick="goToPosition(4)">Matcha Bubble Tea</li>
            <li onclick="goToPosition(5)">Fruit Infused Tea</li>
            <li onclick="goToPosition(6)">Taro Bubble Tea</li>
            <li onclick="goToPosition(7)">Thai Tea</li>
        </ul>
    </div>
    <div id="instructions">Scroll or swipe to navigate through the shop. Tap items for details. Scroll/swipe further for menu.</div>
    <div id="prev-btn" onclick="navigate(-1)">Previous</div>
    <div id="next-btn" onclick="navigate(1)">Next</div>
    <div id="bottom-bar">
        <span id="section-left">I. Exterior</span>
        <div id="progress">
            <div id="progress-fill"></div>
        </div>
        <span id="section-right">II. Interior</span>
    </div>
    <div id="about-overlay">
        <h1>Welcome to Our Bubble Tea Shop</h1>
        <p>Discover the best bubble teas in town! We offer a variety of flavors made with fresh ingredients. Explore our virtual shop to see our offerings up close.</p>
        <p>Our shop is dedicated to providing the highest quality bubble tea experience. From classic milk tea to exotic fruit infusions, there's something for everyone.</p>
        <button id="enter-button">Enter the Shop</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.167.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'https://unpkg.com/three@0.167.0/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://unpkg.com/three@0.167.0/examples/jsm/geometries/TextGeometry.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFFE8AC);
        scene.fog = new THREE.FogExp2(0xFFE8AC, 0.02); // Soft fog for harmony

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 30); // Start farther outside

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.85);
        composer.addPass(bloomPass);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.0);
        pointLight.position.set(0, 8, -5);
        scene.add(pointLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xF9CDD9, roughness: 0.6, metalness: 0 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE8AC, roughness: 0.4 });
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(30, 15, 0.2), wallMaterial);
        backWall.position.set(0, 7.5, -15);
        scene.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 15, 30), wallMaterial);
        leftWall.position.set(-15, 7.5, 0);
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 15, 30), wallMaterial);
        rightWall.position.set(15, 7.5, 0);
        scene.add(rightWall);

        // Front wall for outside view
        const frontWall = new THREE.Mesh(new THREE.BoxGeometry(30, 15, 0.2), wallMaterial);
        frontWall.position.set(0, 7.5, 15);
        scene.add(frontWall);

        // Door in front wall (placeholder)
        const doorGeometry = new THREE.BoxGeometry(5, 10, 0.3);
        const doorMaterial = new THREE.MeshStandardMaterial({ color: 0xF9CDD9 });
        const door = new THREE.Mesh(doorGeometry, doorMaterial);
        door.position.set(0, 5, 15);
        scene.add(door);

        // Counter
        const counterGeometry = new THREE.BoxGeometry(25, 3, 6);
        const counterMaterial = new THREE.MeshStandardMaterial({ color: 0xF9CDD9, metalness: 0.2, roughness: 0.5 });
        const counter = new THREE.Mesh(counterGeometry, counterMaterial);
        counter.position.set(0, 1.5, -10);
        counter.castShadow = true;
        scene.add(counter);

        // Tables
        const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.3 });
        const table1 = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 4), tableMaterial);
        table1.position.set(-8, 1, 5);
        table1.castShadow = true;
        scene.add(table1);

        const table2 = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 4), tableMaterial);
        table2.position.set(8, 1, 5);
        table2.castShadow = true;
        scene.add(table2);

        // Chairs
        const chairMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE8AC, roughness: 0.5 });
        for (let i = -1; i <= 1; i += 2) {
            const chair1 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), chairMaterial);
            chair1.position.set(-8 + i*2, 1, 5);
            chair1.castShadow = true;
            scene.add(chair1);

            const chair2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), chairMaterial);
            chair2.position.set(8 + i*2, 1, 5);
            chair2.castShadow = true;
            scene.add(chair2);
        }

        // Function to create detailed bubble tea placeholder
        function createBubbleTea(x, z, liquidColor, name, desc) {
            const group = new THREE.Group();

            // Cup
            const cupGeo = new THREE.CylinderGeometry(0.8, 0.6, 3, 32);
            const cupMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, roughness: 0.2 });
            const cup = new THREE.Mesh(cupGeo, cupMat);
            cup.position.y = 1.5;
            cup.castShadow = true;
            group.add(cup);

            // Liquid
            const liquidGeo = new THREE.CylinderGeometry(0.75, 0.55, 2.5, 32);
            const liquidMat = new THREE.MeshStandardMaterial({ color: liquidColor, roughness: 0.1, metalness: 0.1 });
            const liquid = new THREE.Mesh(liquidGeo, liquidMat);
            liquid.position.y = 1.25;
            group.add(liquid);

            // Pearls
            for (let i = 0; i < 15; i++) {
                const pearlGeo = new THREE.SphereGeometry(0.15, 16, 16);
                const pearlMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.3 });
                const pearl = new THREE.Mesh(pearlGeo, pearlMat);
                pearl.position.set(Math.random() * 0.5 - 0.25, 0.2 + Math.random() * 0.5, Math.random() * 0.5 - 0.25);
                pearl.castShadow = true;
                group.add(pearl);
            }

            // Straw
            const strawGeo = new THREE.CylinderGeometry(0.08, 0.08, 4, 32);
            const strawMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.2 });
            const straw = new THREE.Mesh(strawGeo, strawMat);
            straw.position.set(0.4, 2, 0);
            straw.rotation.z = Math.PI / 6;
            straw.castShadow = true;
            group.add(straw);

            group.position.set(x, 1.5, z);
            group.userData = { name, desc };
            scene.add(group);
            return group;
        }

        // Create 5 bubble teas with adjusted positions to avoid collision
        const boba1 = createBubbleTea(-8, -10, 0x8B4513, 'Classic Milk Tea', 'Creamy milk tea with chewy tapioca pearls. Refreshing and classic flavor.');
        const boba2 = createBubbleTea(-4, -10, 0x228B22, 'Matcha Bubble Tea', 'Green matcha infused tea with bobas. Healthy and earthy taste.');
        const boba3 = createBubbleTea(0, -10, 0xFF69B4, 'Fruit Infused Tea', 'Fresh fruit flavors mixed with tea and pearls. Sweet and tangy.');
        const boba4 = createBubbleTea(4, -10, 0x9370DB, 'Taro Bubble Tea', 'Smooth taro root flavored tea with bobas. Creamy and nutty.');
        const boba5 = createBubbleTea(8, -10, 0xFFA500, 'Thai Tea', 'Spiced Thai tea with milk and pearls. Bold and aromatic.');

        // Load font for 3D labels
        const fontLoader = new FontLoader();
        const labels = [];
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            function createLabel(text, position) {
                const textGeo = new TextGeometry(text, {
                    font: font,
                    size: 0.5,
                    height: 0.1,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.01,
                    bevelSegments: 5
                });
                const textMat = new THREE.MeshStandardMaterial({ color: 0xF9CDD9 });
                const textMesh = new THREE.Mesh(textGeo, textMat);
                textMesh.position.copy(position);
                textMesh.position.y += 4; // Above boba
                textMesh.position.x -= text.length * 0.2; // Approximate centering
                scene.add(textMesh);
                labels.push(textMesh);
            }

            createLabel('Classic Milk Tea', boba1.position);
            createLabel('Matcha Bubble Tea', boba2.position);
            createLabel('Fruit Infused Tea', boba3.position);
            createLabel('Taro Bubble Tea', boba4.position);
            createLabel('Thai Tea', boba5.position);
        });

        // Hotspots
        const hotspots = [];
        const hotspotPositions = [boba1.position, boba2.position, boba3.position, boba4.position, boba5.position];
        const bobaData = [
            { name: 'Classic Milk Tea', desc: 'Creamy milk tea with chewy tapioca pearls. Refreshing and classic flavor.' },
            { name: 'Matcha Bubble Tea', desc: 'Green matcha infused tea with bobas. Healthy and earthy taste.' },
            { name: 'Fruit Infused Tea', desc: 'Fresh fruit flavors mixed with tea and pearls. Sweet and tangy.' },
            { name: 'Taro Bubble Tea', desc: 'Smooth taro root flavored tea with bobas. Creamy and nutty.' },
            { name: 'Thai Tea', desc: 'Spiced Thai tea with milk and pearls. Bold and aromatic.' }
        ];
        hotspotPositions.forEach((pos, index) => {
            const hotspot = document.createElement('div');
            hotspot.classList.add('hotspot');
            hotspot.innerHTML = '<div class="inner-dot"></div>';
            hotspot.addEventListener('click', (e) => {
                e.stopPropagation();
                showInfo(bobaData[index].name, bobaData[index].desc);
            });
            document.body.appendChild(hotspot);
            hotspots.push({ elem: hotspot, pos: new THREE.Vector3().copy(pos) });
        });

        // Particle effects for bubbles
        const particleGeometry = new THREE.BufferGeometry();
        const particleVertices = [];
        for (let i = 0; i < 500; i++) {
            particleVertices.push(Math.random() * 30 - 15, Math.random() * 15 + 5, Math.random() * 30 - 15);
        }
        particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
        const particleMaterial = new THREE.PointsMaterial({ color: 0xF9CDD9, size: 0.05, transparent: true, opacity: 0.5 });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Animate particles
        function animateParticles() {
            const positions = particleGeometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                if (positions[i] > 20) positions[i] = 5;
            }
            particleGeometry.attributes.position.needsUpdate = true;
        }

        // Premade camera positions (adjusted zoom for full view)
        const positions = [
            { pos: new THREE.Vector3(0, 10, 30), look: new THREE.Vector3(0, 5, 0) }, // Outside view, higher to see whole shop
            { pos: new THREE.Vector3(0, 4, 15), look: new THREE.Vector3(0, 0, -10) }, // Entering
            { pos: new THREE.Vector3(0, 4, 10), look: new THREE.Vector3(0, 0, -10) }, // Approach counter
            { pos: new THREE.Vector3(0, 3, 0), look: new THREE.Vector3(0, 0, -10) }, // Counter overview
            { pos: new THREE.Vector3(-8, 5, -5), look: boba1.position }, // Close to boba1, higher y
            { pos: new THREE.Vector3(-4, 5, -5), look: boba2.position }, // Close to boba2
            { pos: new THREE.Vector3(0, 5, -5), look: boba3.position }, // Close to boba3
            { pos: new THREE.Vector3(4, 5, -5), look: boba4.position }, // Close to boba4
            { pos: new THREE.Vector3(8, 5, -5), look: boba5.position }, // Close to boba5
            { pos: new THREE.Vector3(-10, 3, 5), look: new THREE.Vector3(-8, 1, 5) }, // Table 1 view
            { pos: new THREE.Vector3(10, 3, 5), look: new THREE.Vector3(8, 1, 5) } // Table 2 view
        ];

        let currentIndex = 0;
        let isAnimating = false;
        let wheelDelta = 0;
        const wheelThreshold = 100;
        let touchStartY = 0;

        function animateTo(index) {
            if (isAnimating || index < 0 || index >= positions.length) return;
            isAnimating = true;
            const { pos, look } = positions[index];
            gsap.to(camera.position, {
                x: pos.x, y: pos.y, z: pos.z,
                duration: 1.5,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(look),
                onComplete: () => { isAnimating = false; currentIndex = index; updateProgress(); }
            });
        }

        // Update progress bar
        function updateProgress() {
            document.getElementById('progress-fill').style.width = `${(currentIndex / (positions.length - 1)) * 100}%`;
            // Update section titles if needed
            // document.getElementById('section-left').innerText = 'I. Exterior';
            // document.getElementById('section-right').innerText = 'II. Interior';
        }

        // Navigation function
        window.navigate = function(delta) {
            if (isAnimating) return;
            let newIndex = currentIndex + delta;
            if (newIndex < 0) newIndex = positions.length - 1;
            if (newIndex >= positions.length) newIndex = 0;
            animateTo(newIndex);
            if (newIndex >= positions.length - 2) {
                gsap.to('#menu', { bottom: 0, duration: 0.5 });
            } else {
                gsap.to('#menu', { bottom: -300, duration: 0.5 });
            }
        }

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObject = null;
        const interactables = [boba1, boba2, boba3, boba4, boba5];

        // Mouse move for hover/tooltips
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables, true);
            const tooltip = document.getElementById('tooltip');
            if (intersects.length > 0) {
                hoveredObject = intersects[0].object;
                while (!hoveredObject.userData.name && hoveredObject.parent) hoveredObject = hoveredObject.parent;
                tooltip.innerHTML = `${hoveredObject.userData.name}<br><small>Click to explore</small>`;
 First, the user is complaining about the hotspots (white buttons with red dot). They don't work properly, and they don't look like in the screenshot on click/tap.

From the screenshot, the hotspots are white circles with red dots, and on tap, they show a popup with info and a button.

In my code, I added hotspots as HTML divs projected on screen, but they are not clickable. I need to make them clickable to show the info modal.

To make them interactive, add click event to each hotspot div, but since they are projected, and to associate with boba, perhaps make the hotspot click trigger the same as raycast.

But for simplicity, since raycast works on tap, and hotspots are visual, keep raycast for interaction, but make hotspots pulse or something.

To match, on tap on hotspot, show popup.

But since it's HTML, add onclick to hotspot divs, set targetIndex and show modal.

For each hotspot, assign an index or boba.

The outside view shows only the door; user wants to see the whole shop from outside.

Currently, frontWall is at z=15, camera at z=30, looking at (0,0,0), so it shows the front wall.

To show the whole shop, make front wall transparent or remove, but to have outside view, perhaps make the shop open, or camera higher.

To see inside from outside, make front wall semi-transparent or have windows.

For simplicity, remove front wall or make it invisible, but to have a building, add roof or something.

To polish, add a sign or something on front.

For buttons not working, make hotspots clickable.

In code, when creating hotspot, hotspot.onclick = () => { 
  const index = ...;
  animateTo(index + 3); // since close ups start at 4
  showInfo(name, desc);
}

Assign to each hotspot the corresponding data.

Yes, when creating hotspots, pass the boba.

hotspots.push({ elem: hotspot, pos: pos, boba: the boba });

Then, hotspot.onclick = () => {
  animateTo(h.hotspotIndex + 3); // define index
  showInfo(h.boba.userData.name, h.boba.userData.desc);
}

For look on click, perhaps add animation to hotspot on click, like scale or color change.

But for now, since popup shows.

The screenshot has popup on tap, with button to discover boutique.

So, the modal is the popup.

For camera on bubble close ups too low, increase y to 5 or 6.

Currently y=4, z=-5, boba y=1.5, so increase y to 5.

For outside, to see whole shop, perhaps move camera to (0,10,30), look at (0,5,0), to see over the wall or make wall lower.

Or remove front wall, as it's virtual.

To make it show the whole shop, set camera higher, or make no front wall.

Let's remove front wall for visibility.

For the progress bar, in the screenshot it's 1/5 with dots and line.

To match, adjust the bottom-bar to have numbers 1/5, and dots for progress.

In code, #bottom-bar:

<div id="progress-count">1/5</div>
<div id="progress">
  <div id="progress-fill"></div>
</div>

But to match, add dots.

For simplicity, keep line, but add dots.

<div class="progress-dot active"></div> <line> <dot> etc

But to match exactly, make <span>1/5</span> <div class="progress-line"> <div class="progress-dot active"></div> <line> <dot> <dot> <dot> <dot></div>

The screenshot has 1/5 . - - - - . with blue fill on first dot.

So, use CSS to style dots and line.

Add in style:

.progress-dot {
  width: 10px;
  height: 10px;
  background: white;
  border-radius: 50%;
  display: inline-block;
  margin: 0 5px;
}

.active {
  background: blue;
}

The line is horizontal with dots.

In the code, for bottom-bar:

<span>1/5</span>
<span class="progress-dot active"></span>
<span class="progress-line"></span>
<span class="progress-dot"></span>
<span class="progress-line"></span>
<span class="progress-dot"></span>
<span class="progress-line"></span>
<span class="progress-dot"></span>
<span class="progress-line"></span
<span class="progress-dot"></span>

Then, style progress-line { width: 20px; height: 2px; background: white; display: inline-block; }

To make fill, perhaps use a slider.

Since positions are 11, but for progress, perhaps simplify to 5 sections.

The screenshot has 1/5 for first, so perhaps define 5 key positions.

For now, keep as is, but update to match.

Also, the section left and right like I. L'Univers produits II. La Ros

So, keep.

For hotspots, in the screenshot, they are on items, and tap shows popup.

In my code, hotspots are on bobas, tap on canvas raycasts to show modal.

To make hotspots clickable, since they are overlay, add onclick to hotspot elem.

But to detect tap on hotspot, but since raycast is on canvas, perhaps keep raycast, and hotspots visual only.

To make exact, perhaps remove raycast for mobile, make hotspots clickable.

But since hotspots are projected, and click on hotspot would be on div, not canvas, so add onclick to hotspot to show popup.

Yes, and for desktop, keep raycast.

But to unify, use raycast for all, hotspots visual.

But user said buttons don't work, so make them clickable.

In code, when creating hotspot, hotspot.onclick = () => showInfo for that boba, and animateTo.

Yes.

Also, for popup look like screenshot, style the modal with rounded, with image or icon, text, button.

The screenshot has rounded white card with title, icon, text, blue button.

So, update #info-modal style to match.

Add icon or something.

For now, add <img src="placeholder" > in modal.

But since no image, keep text.

Add class rounded, etc.

For the second screenshot, popup with x close, title, icon, text, blue button.

So, add close x to modal.

In code, add <span class="close" onclick="closeModal()">x</span> in info-modal.

Style .close { position: absolute; top: 10px; right: 10px; cursor: pointer; }

And button blue: background blue, color white.

In screenshot, blue button "Découvrir la boutique"

So, for our modal, make button blue.

But palette is pink yellow, but to match, perhaps change button to blue.

Keep.

For progress, to match, make it with dots.

Update bottom-bar to:

<div id="bottom-bar">
  <span id="section-left">I. L'Univers produits</span>
  <div id="progress">
    <span class="progress-dot active"></span>
    <span class="progress-line"></span>
    <span class="progress-dot"></span>
    <span class="progress-line"></span>
    <span class="progress-dot"></span>
    <span class="progress-line"></span
    <span class="progress-dot"></span>
    <span class="progress-line"></span>
    <span class="progress-dot"></span>
  </div>
  <span id="section-right">II. La Ros</span>
</div>

Then, style:

.progress-dot {
  width: 10px;
  height: 10px;
  background: #fff;
  border-radius: 50%;
  display: inline-block;
}

.progress-line {
  width: 20px;
  height: 2px;
  background: #fff;
  display: inline-block;
  vertical-align: middle;
}

.active {
  background: #00bfff; // blue
}

To update active, in updateProgress, calculate which dot is active based on currentIndex / total.

For 5 dots, total positions 11, perhaps map to 5 sections.

For example, index 0-2: dot 1, 3-7: dot 2-6? Wait, 5 bobas dot 2-6, but simplify to 5 dots for 5 bobas, but keep.

For now, assume 5 dots for the 5 close ups, but since navigation is more, perhaps keep line.

To match, set 5 dots, and active based on current close up.

But for simplicity, use the line with fill.

The user wants exactly like the website, so try to match the progress with dots and line.

The first screenshot has 1/5 . - - - - . with blue on first dot and line to it.

So, left 1/5, then blue dot, white line, white dot, line, dot, line, dot, line, dot, with flowers at end.

For our, ignore flowers, make 5 dots with lines.

In HTML:

<div id="progress-count">1/5</div>
<span class="progress-dot active"></span>
<span class="progress-line"></span>
<span class="progress-dot"></span>
<span class="progress-line"></span>
<span class="progress-dot"></span>
<span class="progress-line"></span>
<span class="progress-dot"></span>
<span class="progress-line"></span>
<span class="progress-dot"></span>

Then, to activate, use JS to set class active on the n-th dot, and perhaps fill line before.

But for simplicity, use CSS for fill, but with dots.

Perhaps use slider.

To match, add class 'filled' to lines before active.

But since it's for boba, perhaps when in close up, set active to the boba index.

For example, for index 4 (boba1), active dot 1, etc.

Yes.

In animateTo, if index >=4 && index <=8, activeDot = index - 3;

Then, const dots = document.querySelectorAll('.progress-dot');

dots.forEach((d, i) => d.classList.toggle('active', i === activeDot - 1));

0 to 4 for 5 dots.

Yes.

Add in style active background blue.

For the line, to fill, add class filled to lines before.

const lines = document.querySelectorAll('.progress-line');

for (let i = 0; i < activeDot - 1; i++) lines[i].classList.add('filled');

Others remove.

Style .progress-line.filled { background: blue; }

Yes.

For progress-count innerText = `${activeDot}/5`

When not in close up, perhaps hide or set 0.

But for now, when in close up.

For section left right, update based on section.

But keep static.

For hotspots, make them clickable.

When creating hotspot, hotspot.onclick = () => {

  const targetIndex = index + 4; // since close ups start at 4 for boba1

  animateTo(targetIndex);

  showInfo(the name, desc);

}

Yes, use closure for index.

For example, hotspots.push({... , index});

Then hotspot.elem.onclick = () => {

  animateTo(h.index + 4);

  showInfo(...)

}

Yes.

For the look on click, perhaps gsap scale the hotspot on click.

gsap.to(h.elem, { scale: 1.2, duration: 0.2, yoyo: true, repeat: 1 });

But since it's div, use transform scale.

Yes.

Add in style hotspot { transition: transform 0.2s; }

On click, hotspot.style.transform = 'scale(1.2)';

setTimeout(() => hotspot.style.transform = 'scale(1)', 200);

Yes.

For the inner dot red, as in screenshot.

In code, inner-dot background red.

Yes.

For the popup, to match, update modal to have rounded, with x, title, icon (add <div class="icon"> <img> or svg )

But since no icon, add a boba icon placeholder.

For example, <div class="icon">🍵</div>

Style .icon { font-size: 40px; margin-bottom: 10px; }

Title, text, blue button "Discover the boutique" but for us "Order Now" or "Learn More".

But keep close button as x.

Add <span class="close" onclick="closeModal()">×</span> in modal.

Style .close { position: absolute; top: 10px; right: 10px; font-size: 20px; cursor: pointer; color: #00bfff; }

For button, make it blue background #00bfff, color white.

Yes.

To polish, add more elements like shelves, but since placeholders, keep.

For rough look, perhaps add textures, but can't without files.

For mushing, with smaller size and spacing, should be better.

Yes.

The code.```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Bubble Tea Shop</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #loading { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: #FFE8AC; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 24px; 
            color: #F9CDD9; 
            z-index: 10;
            opacity: 1;
        }
        #tooltip {
            position: absolute;
            background: rgba(249, 205, 217, 0.95); /* Slightly less opacity for solidity */
            color: #FFE8AC;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: none;
            display: none;
            z-index: 5;
            border: 1px solid #FFE8AC;
        }
        #info-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            color: #000;
            padding: 25px;
            border-radius: 20px;
            max-width: 350px;
            display: none;
            z-index: 6;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            text-align: center;
        }
        #info-modal .close {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            cursor: pointer;
            color: #a0a0a0;
        }
        #info-modal .icon {
            font-size: 60px;
            margin-bottom: 10px;
        }
        #info-modal h2 {
            margin-top: 0;
            font-size: 20px;
        }
        #info-modal p {
            font-size: 16px;
        }
        #info-modal button {
            background: #00bfff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
        }
        #menu {
            position: absolute;
            bottom: -300px; /* Adjusted for more space */
            left: 0;
            width: 100%;
            background: rgba(249, 205, 217, 0.95);
            color: #FFE8AC;
            padding: 25px;
            box-sizing: border-box;
            transition: bottom 0.5s ease;
            z-index: 5;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.2);
        }
        #menu h2 {
            margin-top: 0;
            text-align: center;
        }
        #menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        #menu li {
            margin: 10px;
            padding: 10px 20px;
            background: #FFE8AC;
            color: #F9CDD9;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(249, 205, 217, 0.8);
            color: #FFE8AC;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 5;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        #prev-btn, #next-btn {
            position: absolute;
            bottom: 20px;
            background: #F9CDD9;
            color: #FFE8AC;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 5;
            display: none; /* Show on mobile */
        }
        #prev-btn { left: 20px; }
        #next-btn { right: 20px; }
        @media (max-width: 768px) {
            #prev-btn, #next-btn { display: block; }
            #tooltip { display: none !important; } /* Disable tooltip on mobile */
        }
        #bottom-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80%;
            max-width: 600px;
            z-index: 5;
        }
        #progress-count {
            margin-right: 10px;
            color: #000;
            font-size: 16px;
        }
        .progress-dot {
            width: 10px;
            height: 10px;
            background: #a0a0a0;
            border-radius: 50%;
            display: inline-block;
            margin: 0 5px;
            vertical-align: middle;
        }
        .progress-dot.active {
            background: #00bfff;
        }
        .progress-line {
            width: 20px;
            height: 2px;
            background: #a0a0a0;
            display: inline-block;
            vertical-align: middle;
        }
        .progress-line.filled {
            background: #00bfff;
        }
        .hotspot {
            position: absolute;
            width: 30px;
            height: 30px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            animation: pulse 1.5s infinite;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .inner-dot {
            width: 10px;
            height: 10px;
            background: red;
            border-radius: 50%;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        #about-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 232, 172, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 4;
            text-align: center;
            color: #F9CDD9;
            font-size: 18px;
            padding: 20px;
            opacity: 1;
            transition: opacity 1s ease;
        }
        #about-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #about-overlay h1 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        #about-overlay p {
            max-width: 600px;
            margin-bottom: 20px;
        }
        #enter-button {
            background: #F9CDD9;
            color: #FFE8AC;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Virtual Bubble Tea Shop...</div>
    <div id="tooltip"></div>
    <div id="info-modal">
        <span class="close" onclick="closeModal()">×</span>
        <div class="icon">🍵</div>
        <h2 id="info-title"></h2>
        <p id="info-description"></p>
        <button onclick="closeModal()">Learn More</button>
    </div>
    <div id="menu">
        <h2>Bubble Tea Menu</h2>
        <ul>
            <li onclick="goToPosition(3)">Classic Milk Tea</li>
            <li onclick="goToPosition(4)">Matcha Bubble Tea</li>
            <li onclick="goToPosition(5)">Fruit Infused Tea</li>
            <li onclick="goToPosition(6)">Taro Bubble Tea</li>
            <li onclick="goToPosition(7)">Thai Tea</li>
        </ul>
    </div>
    <div id="instructions">Scroll or swipe to navigate through the shop. Tap hotspots for details. Scroll/swipe further for menu.</div>
    <div id="prev-btn" onclick="navigate(-1)">Previous</div>
    <div id="next-btn" onclick="navigate(1)">Next</div>
    <div id="bottom-bar">
        <span id="progress-count">1/5</span>
        <span class="progress-dot active"></span>
        <span class="progress-line"></span>
        <span class="progress-dot"></span>
        <span class="progress-line"></span>
        <span class="progress-dot"></span>
        <span class="progress-line"></span>
        <span class="progress-dot"></span>
        <span class="progress-line"></span>
        <span class="progress-dot"></span>
    </div>
    <div id="about-overlay">
        <h1>Welcome to Our Bubble Tea Shop</h1>
        <p>Discover the best bubble teas in town! We offer a variety of flavors made with fresh ingredients. Explore our virtual shop to see our offerings up close.</p>
        <p>Our shop is dedicated to providing the highest quality bubble tea experience. From classic milk tea to exotic fruit infusions, there's something for everyone.</p>
        <button id="enter-button">Enter the Shop</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.167.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'https://unpkg.com/three@0.167.0/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://unpkg.com/three@0.167.0/examples/jsm/geometries/TextGeometry.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFFE8AC);
        scene.fog = new THREE.FogExp2(0xFFE8AC, 0.02); // Soft fog for harmony

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 30); // Start farther outside, higher to see whole shop

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.85);
        composer.addPass(bloomPass);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.0);
        pointLight.position.set(0, 8, -5);
        scene.add(pointLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xF9CDD9, roughness: 0.6, metalness: 0 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE8AC, roughness: 0.4 });
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(30, 15, 0.2), wallMaterial);
        backWall.position.set(0, 7.5, -15);
        scene.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 15, 30), wallMaterial);
        leftWall.position.set(-15, 7.5, 0);
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 15, 30), wallMaterial);
        rightWall.position.set(15, 7.5, 0);
        scene.add(rightWall);

        // Counter
        const counterGeometry = new THREE.BoxGeometry(25, 3, 6);
        const counterMaterial = new THREE.MeshStandardMaterial({ color: 0xF9CDD9, metalness: 0.2, roughness: 0.5 });
        const counter = new THREE.Mesh(counterGeometry, counterMaterial);
        counter.position.set(0, 1.5, -10);
        counter.castShadow = true;
        scene.add(counter);

        // Tables
        const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.3 });
        const table1 = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 4), tableMaterial);
        table1.position.set(-8, 1, 5);
        table1.castShadow = true;
        scene.add(table1);

        const table2 = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 4), tableMaterial);
        table2.position.set(8, 1, 5);
        table2.castShadow = true;
        scene.add(table2);

        // Chairs
        const chairMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE8AC, roughness: 0.5 });
        for (let i = -1; i <= 1; i += 2) {
            const chair1 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), chairMaterial);
            chair1.position.set(-8 + i*2, 1, 5);
            chair1.castShadow = true;
            scene.add(chair1);

            const chair2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), chairMaterial);
            chair2.position.set(8 + i*2, 1, 5);
            chair2.castShadow = true;
            scene.add(chair2);
        }

        // Function to create detailed bubble tea placeholder
        function createBubbleTea(x, z, liquidColor, name, desc) {
            const group = new THREE.Group();

            // Cup
            const cupGeo = new THREE.CylinderGeometry(0.8, 0.6, 3, 32);
            const cupMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, roughness: 0.2 });
            const cup = new THREE.Mesh(cupGeo, cupMat);
            cup.position.y = 1.5;
            cup.castShadow = true;
            group.add(cup);

            // Liquid
            const liquidGeo = new THREE.CylinderGeometry(0.75, 0.55, 2.5, 32);
            const liquidMat = new THREE.MeshStandardMaterial({ color: liquidColor, roughness: 0.1, metalness: 0.1 });
            const liquid = new THREE.Mesh(liquidGeo, liquidMat);
            liquid.position.y = 1.25;
            group.add(liquid);

            // Pearls
            for (let i = 0; i < 15; i++) {
                const pearlGeo = new THREE.SphereGeometry(0.15, 16, 16);
                const pearlMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.3 });
                const pearl = new THREE.Mesh(pearlGeo, pearlMat);
                pearl.position.set(Math.random() * 0.5 - 0.25, 0.2 + Math.random() * 0.5, Math.random() * 0.5 - 0.25);
                pearl.castShadow = true;
                group.add(pearl);
            }

            // Straw
            const strawGeo = new THREE.CylinderGeometry(0.08, 0.08, 4, 32);
            const strawMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.2 });
            const straw = new THREE.Mesh(strawGeo, strawMat);
            straw.position.set(0.4, 2, 0);
            straw.rotation.z = Math.PI / 6;
            straw.castShadow = true;
            group.add(straw);

            group.position.set(x, 1.5, z);
            group.userData = { name, desc };
            scene.add(group);
            return group;
        }

        // Create 5 bubble teas with adjusted positions to avoid collision
        const boba1 = createBubbleTea(-8, -10, 0x8B4513, 'Classic Milk Tea', 'Creamy milk tea with chewy tapioca pearls. Refreshing and classic flavor.');
        const boba2 = createBubbleTea(-4, -10, 0x228B22, 'Matcha Bubble Tea', 'Green matcha infused tea with bobas. Healthy and earthy taste.');
        const boba3 = createBubbleTea(0, -10, 0xFF69B4, 'Fruit Infused Tea', 'Fresh fruit flavors mixed with tea and pearls. Sweet and tangy.');
        const boba4 = createBubbleTea(4, -10, 0x9370DB, 'Taro Bubble Tea', 'Smooth taro root flavored tea with bobas. Creamy and nutty.');
        const boba5 = createBubbleTea(8, -10, 0xFFA500, 'Thai Tea', 'Spiced Thai tea with milk and pearls. Bold and aromatic.');

        // Load font for 3D labels
        const fontLoader = new FontLoader();
        const labels = [];
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            function createLabel(text, position) {
                const textGeo = new TextGeometry(text, {
                    font: font,
                    size: 0.5,
                    height: 0.1,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.01,
                    bevelSegments: 5
                });
                const textMat = new THREE.MeshStandardMaterial({ color: 0xF9CDD9 });
                const textMesh = new THREE.Mesh(textGeo, textMat);
                textMesh.position.copy(position);
                textMesh.position.y += 4; // Above boba
                textMesh.position.x -= text.length * 0.2; // Approximate centering
                scene.add(textMesh);
                labels.push(textMesh);
            }

            createLabel('Classic Milk Tea', boba1.position);
            createLabel('Matcha Bubble Tea', boba2.position);
            createLabel('Fruit Infused Tea', boba3.position);
            createLabel('Taro Bubble Tea', boba4.position);
            createLabel('Thai Tea', boba5.position);
        });

        // Hotspots
        const hotspots = [];
        const hotspotPositions = [boba1.position, boba2.position, boba3.position, boba4.position, boba5.position];
        hotspotPositions.forEach((pos, index) => {
            const hotspot = document.createElement('div');
            hotspot.classList.add('hotspot');
            hotspot.innerHTML = '<div class="inner-dot"></div>';
            hotspot.addEventListener('click', (e) => {
                e.stopPropagation();
                hotspot.style.transform = 'scale(1.2)';
                setTimeout(() => hotspot.style.transform = 'scale(1)', 200);
                const targetIndex = index + 4; // close ups start at 4
                animateTo(targetIndex);
                showInfo(bobaData[index].name, bobaData[index].desc);
            });
            document.body.appendChild(hotspot);
            hotspots.push({ elem: hotspot, pos: new THREE.Vector3().copy(pos) });
        });

        // Particle effects for bubbles
        const particleGeometry = new THREE.BufferGeometry();
        const particleVertices = [];
        for (let i = 0; i < 500; i++) {
            particleVertices.push(Math.random() * 30 - 15, Math.random() * 15 + 5, Math.random() * 30 - 15);
        }
        particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
        const particleMaterial = new THREE.PointsMaterial({ color: 0xF9CDD9, size: 0.05, transparent: true, opacity: 0.5 });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Animate particles
        function animateParticles() {
            const positions = particleGeometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                if (positions[i] > 20) positions[i] = 5;
            }
            particleGeometry.attributes.position.needsUpdate = true;
        }

        // Premade camera positions (adjusted zoom for full view)
        const positions = [
            { pos: new THREE.Vector3(0, 10, 30), look: new THREE.Vector3(0, 5, 0) }, // Outside view, higher to see whole shop
            { pos: new THREE.Vector3(0, 4, 15), look: new THREE.Vector3(0, 0, -10) }, // Entering
            { pos: new THREE.Vector3(0, 4, 10), look: new THREE.Vector3(0, 0, -10) }, // Approach counter
            { pos: new THREE.Vector3(0, 3, 0), look: new THREE.Vector3(0, 0, -10) }, // Counter overview
            { pos: new THREE.Vector3(-8, 5, -5), look: boba1.position }, // Close to boba1, higher y
            { pos: new THREE.Vector3(-4, 5, -5), look: boba2.position }, // Close to boba2
            { pos: new THREE.Vector3(0, 5, -5), look: boba3.position }, // Close to boba3
            { pos: new THREE.Vector3(4, 5, -5), look: boba4.position }, // Close to boba4
            { pos: new THREE.Vector3(8, 5, -5), look: boba5.position }, // Close to boba5
            { pos: new THREE.Vector3(-10, 3, 5), look: new THREE.Vector3(-8, 1, 5) }, // Table 1 view
            { pos: new THREE.Vector3(10, 3, 5), look: new THREE.Vector3(8, 1, 5) } // Table 2 view
        ];

        let currentIndex = 0;
        let isAnimating = false;
        let wheelDelta = 0;
        const wheelThreshold = 100;
        let touchStartY = 0;

        function animateTo(index) {
            if (isAnimating || index < 0 || index >= positions.length) return;
            isAnimating = true;
            const { pos, look } = positions[index];
            gsap.to(camera.position, {
                x: pos.x, y: pos.y, z: pos.z,
                duration: 1.5,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(look),
                onComplete: () => The tool returned insufficient content, just "Pop 10 ans La Rosée" and "Chargement", no code.

I need to use another tool to get the source.

Use browse_page with instructions to get the page source.

The tool says "It will fetch the page and process it via the LLM summarizer", so for code, ask for full HTML or key parts.

But it returned insufficient.

Perhaps the page is JS rendered, so tool can't get dynamic content.

To replicate, reason from screenshots.

From first screenshot:

- Logo at top.

- Hotspots on items: white circle with red dot.

- Bottom: section left "I. L'Univers produits", progress with 1/5 blue dot - white line - white dot etc with flowers.

- On tap hotspot, popup with title, icon, text, blue button.

Second screenshot: popup with x, title "Offre exclusive", icon bag, text, blue button "Découvrir la boutique"

Third screenshot: different room, hotspot on curtain, text "Tirez pour découvrir le secret", shopping icon, bottom 2/8 progress with blue on second dot.

To replicate:

- Hotspots: white circle red dot, pulse.

- On click/tap, show popup modal with x, title, icon (emoji or something), text, blue button "Order Now" or "Learn More" that closes or links.

For button, perhaps close modal.

For progress, make with dots and lines, active blue.

For 5 bobas, 5 dots.

In bottom-bar:

<div id="progress-count"></div>
<div id="progress-container">
  <span class="progress-dot"></span>
  <span class="progress-line"></span>
  <span class="progress-dot"></span>
  <span class="progress-line"></span>
  <span class="progress-dot"></span>
  <span class="progress-line"></span>
  <span class="progress-dot"></span>
  <span class="progress-line"></span>
  <span class="progress-dot"></span>
</div>

Style:

#progress-count { color: #000; font-size: 14px; }

#progress-container { display: flex; align-items: center; flex: 1; justify-content: center; }

.progress-dot {
  width: 8px;
  height: 8px;
  background: #ccc;
  border-radius: 50%;
}

.progress-line {
  width: 20px;
  height: 2px;
  background: #ccc;
}

.active-dot {
  background: #00bfff;
}

.active-line {
  background: #00bfff;
}

In updateProgress, if currentIndex >=4 && currentIndex <=8, let active = currentIndex - 3;

document.getElementById('progress-count').innerText = `${active}/5`;

const dots = document.querySelectorAll('.progress-dot');

const lines = document.querySelectorAll('.progress-line');

dots.forEach((d, i) => d.classList.toggle('active-dot', i < active));

lines.forEach((l, i) => l.classList.toggle('active-line', i < active - 1));

Dots 0 to 4, active 1 to 5, i < active for dots? For active=1, dot0 active, lines none.

For active=2, dot0 and dot1 active? No, in screenshot, for 1/5, first dot blue, line white.

The screenshot has blue dot for current, line before filled blue? But in first, 1/5 blue dot, white line to next.

Perhaps only current dot blue, previous lines blue.

For 1, first dot blue, no line filled.

For 2, first line blue, second dot blue.

Yes.

So, dots[i].toggle('active-dot', i + 1 === active);

lines[i].toggle('active-line', i + 1 < active);

Yes, i from 0 to 3 for lines, 0 to 4 for dots.

Perfect.

For section left right, make dynamic if needed.

For popup, add x close.

In modal HTML:

<div id="info-modal">
  <span class="close" onclick="closeModal()">×</span>
  <h2 id="info-title"></h2>
  <p id="info-description"></p>
  <button onclick="closeModal()">Close</button>
</div>

Style .close { position: absolute; top: 10px; right: 10px; font-size: 24px; color: #ccc; cursor: pointer; }

For icon, add <div class="icon">🍵</div> before h2.

Style .icon { font-size: 50px; margin-bottom: 10px; }

For button, make it blue: background: #00bfff; color: white;

Yes.

For hotspots clickable, but since raycast works, and for mobile, raycast on tap works, but to make hotspots interact, perhaps set pointer-events: auto on hotspot, but since raycast is on canvas, if click on hotspot div, it won't reach canvas, so to make consistent, remove raycast click, use hotspots for interaction.

No, to fix, make hotspots pointer-events: none, so click passes to canvas.

Then, raycast handles.

But user said buttons don't work, perhaps because pointer-events none.

In code, pointer-events: none on hotspot, so click passes to canvas.

To make them work, remove pointer-events: none, add onclick to hotspot, but then click on hotspot doesn't raycast.

To unify, keep pointer-events: none, rely on raycast.

Perhaps the problem is raycast not working on mobile, but it should.

To fix, add touchend event for raycast.

Currently, window.addEventListener('click', onMouseClick);

For mobile, click works on touch.

But to be sure, add 'touchend' event with similar, set mouse from e.changedTouches[0]

Yes, to make accurate on mobile.

Add:

window.addEventListener('touchend', (e) => {
  mouse.x = (e.changedTouches[0].clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.changedTouches[0].clientY / window.innerHeight) * 2 + 1;
  onMouseClick(e); // call the same function
});

Yes.

For outside view, to show whole shop, since no front wall, but in code there is front wall, to see inside, make front wall transparent.

Set frontWall.material.transparent = true; opacity = 0.5; or remove frontWall.

To show whole, remove front wall and door, as it's virtual.

Remove those lines.

Yes.

For camera, in positions[0] { pos: new THREE.Vector3(0, 10, 30), look: new THREE.Vector3(0, 5, 0) }

Yes.

The code.```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Bubble Tea Shop</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #loading { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: #FFE8AC; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 24px; 
            color: #F9CDD9; 
            z-index: 10;
            opacity: 1;
        }
        #tooltip {
            position: absolute;
            background: rgba(249, 205, 217, 0.95); /* Slightly less opacity for solidity */
            color: #FFE8AC;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: none;
            display: none;
            z-index: 5;
            border: 1px solid #FFE8AC;
        }
        #info-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #FFE8AC;
            color: #F9CDD9;
            padding: 25px;
            border-radius: 12px;
            max-width: 350px;
            display: none;
            z-index: 6;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            text-align: center;
        }
        #info-modal .close {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            color: #ccc;
            cursor: pointer;
        }
        #info-modal .icon {
            font-size: 50px;
            margin-bottom: 10px;
        }
        #info-modal h2 {
            margin-top: 0;
            font-size: 20px;
        }
        #info-modal p {
            font-size: 16px;
        }
        #info-modal button {
            background: #00bfff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        #menu {
            position: absolute;
            bottom: -300px; /* Adjusted for more space */
            left: 0;
            width: 100%;
            background: rgba(249, 205, 217, 0.95);
            color: #FFE8AC;
            padding: 25px;
            box-sizing: border-box;
            transition: bottom 0.5s ease;
            z-index: 5;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.2);
        }
        #menu h2 {
            margin-top: 0;
            text-align: center;
        }
        #menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        #menu li {
            margin: 10px;
            padding: 10px 20px;
            background: #FFE8AC;
            color: #F9CDD9;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(249, 205, 217, 0.8);
            color: #FFE8AC;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 5;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        #prev-btn, #next-btn {
            position: absolute;
            bottom: 20px;
            background: #F9CDD9;
            color: #FFE8AC;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 5;
            display: none; /* Show on mobile */
        }
        #prev-btn { left: 20px; }
        #next-btn { right: 20px; }
        @media (max-width: 768px) {
            #prev-btn, #next-btn { display: block; }
            #tooltip { display: none !important; } /* Disable tooltip on mobile */
        }
        #bottom-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 80%;
            max-width: 600px;
            z-index: 5;
        }
        #section-left, #section-right {
            font-size: 16px;
            color: #F9CDD9;
        }
        #progress {
            flex: 1;
            margin: 0 20px;
            height: 5px;
            background: #F9CDD9;
            border-radius: 5px;
            position: relative;
        }
        #progress-fill {
            height: 100%;
            background: #FFE8AC;
            border-radius: 5px;
            transition: width 0.5s ease;
        }
        .hotspot {
            position: absolute;
            width: 30px;
            height: 30px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            animation: pulse 1.5s infinite;
            cursor: pointer;
        }
        .inner-dot {
            width: 10px;
            height: 10px;
            background: red;
            border-radius: 50%;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        #about-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 232, 172, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 4;
            text-align: center;
            color: #F9CDD9;
            font-size: 18px;
            padding: 20px;
            opacity: 1;
            transition: opacity 1s ease;
        }
        #about-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #about-overlay h1 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        #about-overlay p {
            max-width: 600px;
            margin-bottom: 20px;
        }
        #enter-button {
            background: #F9CDD9;
            color: #FFE8AC;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Virtual Bubble Tea Shop...</div>
    <div id="tooltip"></div>
    <div id="info-modal">
        <span class="close" onclick="closeModal()">×</span>
        <div class="icon">🍵</div>
        <h2 id="info-title"></h2>
        <p id="info-description"></p>
        <button onclick="closeModal()">Learn More</button>
    </div>
    <div id="menu">
        <h2>Bubble Tea Menu</h2>
        <ul>
            <li onclick="goToPosition(3)">Classic Milk Tea</li>
            <li onclick="goToPosition(4)">Matcha Bubble Tea</li>
            <li onclick="goToPosition(5)">Fruit Infused Tea</li>
            <li onclick="goToPosition(6)">Taro Bubble Tea</li>
            <li onclick="goToPosition(7)">Thai Tea</li>
        </ul>
    </div>
    <div id="instructions">Scroll or swipe to navigate through the shop. Tap items for details. Scroll/swipe further for menu.</div>
    <div id="prev-btn" onclick="navigate(-1)">Previous</div>
    <div id="next-btn" onclick="navigate(1)">Next</div>
    <div id="bottom-bar">
        <span id="section-left">I. Exterior</span>
        <div id="progress">
            <div id="progress-fill"></div>
        </div>
        <span id="section-right">II. Interior</span>
    </div>
    <div id="about-overlay">
        <h1>Welcome to Our Bubble Tea Shop</h1>
        <p>Discover the best bubble teas in town! We offer a variety of flavors made with fresh ingredients. Explore our virtual shop to see our offerings up close.</p>
        <p>Our shop is dedicated to providing the highest quality bubble tea experience. From classic milk tea to exotic fruit infusions, there's something for everyone.</p>
        <button id="enter-button">Enter the Shop</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.167.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.167.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'https://unpkg.com/three@0.167.0/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://unpkg.com/three@0.167.0/examples/jsm/geometries/TextGeometry.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFFE8AC);
        scene.fog = new THREE.FogExp2(0xFFE8AC, 0.02); // Soft fog for harmony

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 30); // Start farther outside

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.85);
        composer.addPass(bloomPass);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.0);
        pointLight.position.set(0, 8, -5);
        scene.add(pointLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xF9CDD9, roughness: 0.6, metalness: 0 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE8AC, roughness: 0.4 });
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(30, 15, 0.2), wallMaterial);
        backWall.position.set(0, 7.5, -15);
        scene.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 15, 30), wallMaterial);
        leftWall.position.set(-15, 7.5, 0);
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 15, 30), wallMaterial);
        rightWall.position.set(15, 7.5, 0);
        scene.add(rightWall);

        // Counter
        const counterGeometry = new THREE.BoxGeometry(25, 3, 6);
        const counterMaterial = new THREE.MeshStandardMaterial({ color: 0xF9CDD9, metalness: 0.2, roughness: 0.5 });
        const counter = new THREE.Mesh(counterGeometry, counterMaterial);
        counter.position.set(0, 1.5, -10);
        counter.castShadow = true;
        scene.add(counter);

        // Tables
        const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.3 });
        const table1 = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 4), tableMaterial);
        table1.position.set(-8, 1, 5);
        table1.castShadow = true;
        scene.add(table1);

        const table2 = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 4), tableMaterial);
        table2.position.set(8, 1, 5);
        table2.castShadow = true;
        scene.add(table2);

        // Chairs
        const chairMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE8AC, roughness: 0.5 });
        for (let i = -1; i <= 1; i += 2) {
            const chair1 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), chairMaterial);
            chair1.position.set(-8 + i*2, 1, 5);
            chair1.castShadow = true;
            scene.add(chair1);

            const chair2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), chairMaterial);
            chair2.position.set(8 + i*2, 1, 5);
            chair2.castShadow = true;
            scene.add(chair2);
        }

        // Function to create detailed bubble tea placeholder
        function createBubbleTea(x, z, liquidColor, name, desc) {
            const group = new THREE.Group();

            // Cup
            const cupGeo = new THREE.CylinderGeometry(0.8, 0.6, 3, 32);
            const cupMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, roughness: 0.2 });
            const cup = new THREE.Mesh(cupGeo, cupMat);
            cup.position.y = 1.5;
            cup.castShadow = true;
            group.add(cup);

            // Liquid
            const liquidGeo = new THREE.CylinderGeometry(0.75, 0.55, 2.5, 32);
            const liquidMat = new THREE.MeshStandardMaterial({ color: liquidColor, roughness: 0.1, metalness: 0.1 });
            const liquid = new THREE.Mesh(liquidGeo, liquidMat);
            liquid.position.y = 1.25;
            group.add(liquid);

            // Pearls
            for (let i = 0; i < 15; i++) {
                const pearlGeo = new THREE.SphereGeometry(0.15, 16, 16);
                const pearlMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.3 });
                const pearl = new THREE.Mesh(pearlGeo, pearlMat);
                pearl.position.set(Math.random() * 0.5 - 0.25, 0.2 + Math.random() * 0.5, Math.random() * 0.5 - 0.25);
                pearl.castShadow = true;
                group.add(pearl);
            }

            // Straw
            const strawGeo = new THREE.CylinderGeometry(0.08, 0.08, 4, 32);
            const strawMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.2 });
            const straw = new THREE.Mesh(strawGeo, strawMat);
            straw.position.set(0.4, 2, 0);
            straw.rotation.z = Math.PI / 6;
            straw.castShadow = true;
            group.add(straw);

            group.position.set(x, 1.5, z);
            group.userData = { name, desc };
            scene.add(group);
            return group;
        }

        // Create 5 bubble teas with adjusted positions to avoid collision
        const boba1 = createBubbleTea(-8, -10, 0x8B4513, 'Classic Milk Tea', 'Creamy milk tea with chewy tapioca pearls. Refreshing and classic flavor.');
        const boba2 = createBubbleTea(-4, -10, 0x228B22, 'Matcha Bubble Tea', 'Green matcha infused tea with bobas. Healthy and earthy taste.');
        const boba3 = createBubbleTea(0, -10, 0xFF69B4, 'Fruit Infused Tea', 'Fresh fruit flavors mixed with tea and pearls. Sweet and tangy.');
        const boba4 = createBubbleTea(4, -10, 0x9370DB, 'Taro Bubble Tea', 'Smooth taro root flavored tea with bobas. Creamy and nutty.');
        const boba5 = createBubbleTea(8, -10, 0xFFA500, 'Thai Tea', 'Spiced Thai tea with milk and pearls. Bold and aromatic.');

        // Load font for 3D labels
        const fontLoader = new FontLoader();
        const labels = [];
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            function createLabel(text, position) {
                const textGeo = new TextGeometry(text, {
                    font: font,
                    size: 0.5,
                    height: 0.1,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.01,
                    bevelSegments: 5
                });
                const textMat = new THREE.MeshStandardMaterial({ color: 0xF9CDD9 });
                const textMesh = new THREE.Mesh(textGeo, textMat);
                textMesh.position.copy(position);
                textMesh.position.y += 4; // Above boba
                textMesh.position.x -= text.length * 0.2; // Approximate centering
                scene.add(textMesh);
                labels.push(textMesh);
            }

            createLabel('Classic Milk Tea', boba1.position);
            createLabel('Matcha Bubble Tea', boba2.position);
            createLabel('Fruit Infused Tea', boba3.position);
            createLabel('Taro Bubble Tea', boba4.position);
            createLabel('Thai Tea', boba5.position);
        });

        // Hotspots
        const hotspots = [];
        const hotspotPositions = [boba1.position, boba2.position, boba3.position, boba4.position, boba5.position];
        hotspotPositions.forEach((pos, index) => {
            const hotspot = document.createElement('div');
            hotspot.classList.add('hotspot');
            hotspot.innerHTML = '<div class="inner-dot"></div>';
            hotspot.addEventListener('click', (e) => {
                e.stopPropagation();
                hotspot.style.transform = 'scale(1.2)';
                setTimeout(() => hotspot.style.transform = 'scale(1)', 200);
                const targetIndex = index + 4; // close ups start at 4
                animateTo(targetIndex);
                showInfo(bobaData[index].name, bobaData[index].desc);
            });
            document.body.appendChild(hotspot);
            hotspots.push({ elem: hotspot, pos: new THREE.Vector3().copy(pos) });
        });

        // Particle effects for bubbles
        const particleGeometry = new THREE.BufferGeometry();
        const particleVertices = [];
        for (let i = 0; i < 500; i++) {
            particleVertices.push(Math.random() * 30 - 15, Math.random() * 15 + 5, Math.random() * 30 - 15);
        }
        particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
        const particleMaterial = new THREE.PointsMaterial({ color: 0xF9CDD9, size: 0.05, transparent: true, opacity: 0.5 });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Animate particles
        function animateParticles() {
            const positions = particleGeometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                if (positions[i] > 20) positions[i] = 5;
            }
            particleGeometry.attributes.position.needsUpdate = true;
        }

        // Premade camera positions (adjusted zoom for full view)
        const positions = [
            { pos: new THREE.Vector3(0, 10, 30), look: new THREE.Vector3(0, 5, 0) }, // Outside view, higher to see whole shop
            { pos: new THREE.Vector3(0, 4, 15), look: new THREE.Vector3(0, 0, -10) }, // Entering
            { pos: new THREE.Vector3(0, 4, 10), look: new THREE.Vector3(0, 0, -10) }, // Approach counter
            { pos: new THREE.Vector3(0, 3, 0), look: new THREE.Vector3(0, 0, -10) }, // Counter overview
            { pos: new THREE.Vector3(-8, 6, -5), look: boba1.position }, // Close to boba1, higher y
            { pos: new THREE.Vector3(-4, 6, -5), look: boba2.position }, // Close to boba2
            { pos: new THREE.Vector3(0, 6, -5), look: boba3.position }, // Close to boba3
            { pos: new THREE.Vector3(4, 6, -5), look: boba4.position }, // Close to boba4
            { pos: new THREE.Vector3(8, 6, -5), look: boba5.position }, // Close to boba5
            { pos: new THREE.Vector3(-10, 3, 5), look: new THREE.Vector3(-8, 1, 5) }, // Table 1 view
            { pos: new THREE.Vector3(10, 3, 5), look: new THREE.Vector3(8, 1, 5) } // Table 2 view
        ];

        let currentIndex = 0;
        let isAnimating = false;
        let wheelDelta = 0;
        const wheelThreshold = 100;
        let touchStartY = 0;

        function animateTo(index) {
            if (isAnimating || index < 0 || index >= positions.length) return;
            isAnimating = true;
            const { pos, look } = positions[index];
            gsap.to(camera.position, {
                x: pos.x, y: pos.y, z: pos.z,
                duration: 1.5,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(look),
                onComplete: () => { isAnimating = false; currentIndex = index; updateProgress(); }
            });
        }

        // Update progress bar
        function updateProgress() {
            document.getElementById('progress-fill').style.width = `${(currentIndex / (positions.length - 1)) * 100}%`;
            // Update section titles if needed
            // document.getElementById('section-left').innerText = 'I. Exterior';
            // document.getElementById('section-right').innerText = 'II. Interior';
        }

        // Navigation function
        window.navigate = function(delta) {
            if (isAnimating) return;
            let newIndex = currentIndex + delta;
            if (newIndex < 0) newIndex = positions.length - 1;
            if (newIndex >= positions.length) newIndex = 0;
            animateTo(newIndex);
            if (newIndex >= positions.length - 2) {
                gsap.to('#menu', { bottom: 0, duration: 0.5 });
            } else {
                gsap.to('#menu', { bottom: -300, duration: 0.5 });
            }
        }

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObject = null;
        const interactables = [boba1, boba2, boba3, boba4, boba5];

        // Mouse move for hover/tooltips
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables, true);
            const tooltip = document.getElementById('tooltip');
            if (intersects.length > 0) {
                hoveredObject = intersects[0].object;
                while (!hoveredObject.userData.name && hoveredObject.parent) hoveredObject = hoveredObject.parent;
                tooltip.innerHTML = `${hoveredObject.userData.name}<br><small>Click to explore</small>`;
                tooltip.style.display = 'block';
                tooltip.style.left = `${event.clientX + 15}px`;
                tooltip.style.top = `${event.clientY + 15}px`;
            } else {
                hoveredObject = null;
                tooltip.style.display = 'none';
            }
        }
        window.addEventListener('mousemove', onMouseMove);

        // Click for info and go to position
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables, true);
            if (intersects.length > 0) {
                let selected = intersects[0].object;
                while (!selected.userData.name && selected.parent) selected = selected.parent;
                let targetIndex;
                if (selected === boba1) targetIndex = 4;
                else if (selected === boba2) targetIndex = 5;
                else if (selected === boba3) targetIndex = 6;
                else if (selected === boba4) targetIndex = 7;
                else if (selected === boba5) targetIndex = 8;
                if (targetIndex !== undefined) {
                    animateTo(targetIndex);
                    showInfo(selected.userData.name, selected.userData.desc);
                }
            }
        }
        window.addEventListener('click', onMouseClick);

        // Touch for raycast on mobile
        window.addEventListener('touchend', (e) => {
            mouse.x = (e.changedTouches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.changedTouches[0].clientY / window.innerHeight) * 2 + 1;
            onMouseClick(e);
        });

        // Show info modal
        function showInfo(title, desc) {
            document.getElementById('info-title').innerText = title;
            document.getElementById('info-description').innerText = desc;
            document.getElementById('info-modal').style.display = 'block';
        }

        // Close modal
        window.closeModal = function() {
            document.getElementById('info-modal').style.display = 'none';
        }

        // Scroll to navigate
        window.addEventListener('wheel', (event) => {
            if (isAnimating) return;
            wheelDelta += event.deltaY;
            if (Math.abs(wheelDelta) >= wheelThreshold) {
                let delta = Math.sign(wheelDelta);
                navigate(delta);
                wheelDelta = 0;
            }
        });

        // Touch for mobile
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            if (isAnimating) return;
            let touchEndY = e.changedTouches[0].clientY;
            let deltaY = touchStartY - touchEndY;
            if (Math.abs(deltaY) > 50) {
                let delta = Math.sign(deltaY);
                navigate(delta);
            }
        }, { passive: true });

        // Go to position from menu
        window.goToPosition = function(index) {
            animateTo(index);
            gsap.to('#menu', { bottom: -300, duration: 0.5 });
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            animateParticles();
            rotateBobas();
            labels.forEach(label => label.lookAt(camera.position));
            // Update hotspots positions
            hotspots.forEach(h => {
                const vec = h.pos.clone();
                vec.project(camera);
                if (vec.z < 1) {
                    h.elem.style.left = (vec.x * 0.5 + 0.5) * window.innerWidth + 'px';
                    h.elem.style.top = (-vec.y * 0.5 + 0.5) * window.innerHeight + 'px';
                    h.elem.style.display = 'flex';
                } else {
                    h.elem.style.display = 'none';
                }
            });
            composer.render();
        }
        animate();

        // Entrance animation
        animateTo(0); // Start at outside

        // Fade out loading
        gsap.to('#loading', { 
            opacity: 0, 
            duration: 1, 
            delay: 3, 
            onComplete: () => document.getElementById('loading').style.display = 'none' 
        });

        // Fade out instructions after a while
        gsap.to('#instructions', { 
            opacity: 0, 
            duration: 1, 
            delay: 10, 
            onComplete: () => document.getElementById('instructions').style.display = 'none' 
        });

        // Gentle bouncing for bubble teas
        gsap.to([boba1.position, boba2.position, boba3.position, boba4.position, boba5.position], {
            y: "+=0.1",
            duration: 2,
            repeat: -1,
            yoyo: true,
            ease: "sine.inOut",
            stagger: 0.3
        });

        // Rotate bubble teas slowly for effect
        function rotateBobas() {
            boba1.rotation.y += 0.005;
            boba2.rotation.y += 0.005;
            boba3.rotation.y += 0.005;
            boba4.rotation.y += 0.005;
            boba5.rotation.y += 0.005;
        }

        // Enter button to start exploration
        document.getElementById('enter-button').addEventListener('click', () => {
            gsap.to('#about-overlay', { opacity: 0, duration: 1, onComplete: () => document.getElementById('about-overlay').classList.add('hidden') });
            animateTo(1); // Move inside
        });

        updateProgress();
    </script>
</body>
</html>
